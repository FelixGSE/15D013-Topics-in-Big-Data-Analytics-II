print( K[[k]] - K[[(k+1)]] )
if( K[[k]] - K[[(k+1)]] == 10**(-6) ){
K <- K[[k]]
print(K)
break
}
}
L <- - solve( t(B) %*% K  %*% B + R) %*% t(B) %*% K %*% A
set.seed(1)
# Compute states
for( k in 2:N ){
u.temp <- L %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(w)
}
# Return states
return(x)
}
rigati.states()
rigati.states <- function(  N  = 100,
x0 = c(1,1),
D  = diag(2),
R  = diag(2) * c( 1, 2 ) ,
A  = matrix( sample(6,4,replace=TRUE), 2, 2),
B  = matrix( sample(6,4,replace=TRUE), 2, 2),
C  = c( 1, 1 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize matrices
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K <- list()
K[[N]]  <- Q
# Compute K and L matrices
for ( k in (N-1):1 ){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
if( K[[k]] - K[[(k+1)]] == 10**(-6) ){
K <- K[[k]]
print(K)
break
}
}
L <- - solve( t(B) %*% K  %*% B + R) %*% t(B) %*% K %*% A
set.seed(1)
# Compute states
for( k in 2:N ){
u.temp <- L %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(w)
}
# Return states
return(x)
}
rigati.states()
rigati.states <- function(  N  = 100,
x0 = c(1,1),
D  = diag(2),
R  = diag(2) * c( 1, 2 ) ,
A  = matrix( sample(6,4,replace=TRUE), 2, 2),
B  = matrix( sample(6,4,replace=TRUE), 2, 2),
C  = c( 1, 1 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize matrices
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K <- list()
K[[N]]  <- Q
# Compute K and L matrices
for ( k in (N-1):1 ){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
if( ( K[[k]] - K[[(k+1)]] ) == 10**(-6) ){
K <- K[[k]]
print(K)
break
}
}
L <- - solve( t(B) %*% K  %*% B + R) %*% t(B) %*% K %*% A
set.seed(1)
# Compute states
for( k in 2:N ){
u.temp <- L %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(w)
}
# Return states
return(x)
}
rigati.states()
rigati.states <- function(  N  = 100,
x0 = c(1,1),
D  = diag(2),
R  = diag(2) * c( 1, 2 ) ,
A  = matrix( sample(6,4,replace=TRUE), 2, 2),
B  = matrix( sample(6,4,replace=TRUE), 2, 2),
C  = c( 1, 1 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize matrices
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K <- list()
K[[N]]  <- Q
# Compute K and L matrices
for ( k in (N-1):1 ){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
if( sum( ( K[[k]] - K[[(k+1)]] ) ) == 10**(-6) ){
K <- K[[k]]
print(K)
break
}
}
L <- - solve( t(B) %*% K  %*% B + R) %*% t(B) %*% K %*% A
set.seed(1)
# Compute states
for( k in 2:N ){
u.temp <- L %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(w)
}
# Return states
return(x)
}
rigati.states()
rigati.states <- function(  N  = 100,
x0 = c(1,1),
D  = diag(2),
R  = diag(2) * c( 1, 2 ) ,
A  = matrix( sample(6,4,replace=TRUE), 2, 2),
B  = matrix( sample(6,4,replace=TRUE), 2, 2),
C  = c( 1, 1 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize matrices
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K <- list()
K[[N]]  <- Q
# Compute K and L matrices
for ( k in (N-1):1 ){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
if( sum( ( K[[k]] - K[[(k+1)]] ) ) < 10**(-6) ){
K <- K[[k]]
print(K)
break
}
}
L <- - solve( t(B) %*% K  %*% B + R) %*% t(B) %*% K %*% A
set.seed(1)
# Compute states
for( k in 2:N ){
u.temp <- L %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(w)
}
# Return states
return(x)
}
rigati.states()
rigati.states <- function(  N  = 100,
x0 = c(1,1),
D  = diag(2),
R  = diag(2) * c( 1, 2 ) ,
A  = matrix( sample(6,4,replace=TRUE), 2, 2),
B  = matrix( sample(6,4,replace=TRUE), 2, 2),
C  = c( 1, 1 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize matrices
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K <- list()
K[[N]]  <- Q
# Compute K and L matrices
for ( k in (N-1):1 ){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
if( sum( ( K[[k]] - K[[(k+1)]] ) ) < 10**(-6) ){
K <- K[[(k+1)]]
print(K)
break
}
}
L <- - solve( t(B) %*% K  %*% B + R) %*% t(B) %*% K %*% A
set.seed(1)
# Compute states
for( k in 2:N ){
u.temp <- L %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(w)
}
# Return states
return(x)
}
rigati.states()
mu      <- c( 0 , 0 )
D
D  = diag(2) * c(0.5,0.2)
w      <- rmvnorm( 100 , mean = mu , sigma = D )
if (!require("mvtnorm")) install.packages("mvtnorm"); library(mvtnorm)
w      <- rmvnorm( 100 , mean = mu , sigma = D )
w
w[[1]]
w[1,]
t(w[1,])
compute.states <- function(  N  = 100,
x0 = c(3,2),
D  = diag(2) * c(0.5,0.2),
R  = diag(2) * c( 2, 1 ) ,
A  = matrix( c(0,3,0,0), 2, 2),
B  = matrix( c(4,2,0,1), 2, 2),
C  = c( 5, 0 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(AM(w[(k-1),]))
}
compute.states <- function(  N  = 100,
x0 = c(3,2),
D  = diag(2) * c(0.5,0.2),
R  = diag(2) * c( 2, 1 ) ,
A  = matrix( c(0,3,0,0), 2, 2),
B  = matrix( c(4,2,0,1), 2, 2),
C  = c( 5, 0 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(AM(w[(k-1),]))
}
}
compute.states <- function(  N  = 100,
x0 = c(3,2),
D  = diag(2) * c(0.5,0.2),
R  = diag(2) * c( 2, 1 ) ,
A  = matrix( c(0,3,0,0), 2, 2),
B  = matrix( c(4,2,0,1), 2, 2),
C  = c( 5, 0 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(AM(w[(k-1),]))
}
}
}
compute.states <- function(  N  = 100,
x0 = c(3,2),
D  = diag(2) * c(0.5,0.2),
R  = diag(2) * c( 2, 1 ) ,
A  = matrix( c(0,3,0,0), 2, 2),
B  = matrix( c(4,2,0,1), 2, 2),
C  = c( 5, 0 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + t(AM(w[(k-1),]))
}
}
compute.states
compute.states()
compute.states <- function(  N  = 100,
x0 = c(3,2),
D  = diag(2) * c(0.5,0.2),
R  = diag(2) * c( 2, 1 ) ,
A  = matrix( c(0,3,0,0), 2, 2),
B  = matrix( c(4,2,0,1), 2, 2),
C  = c( 5, 0 ) )
{
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + AM(w[(k-1),])
}
}
compute.states()
N  = 100
x0 = c(3,2)
D  = diag(2) * c(0.5,0.2)
R  = diag(2) * c( 2, 1 )
A  = matrix( c(0,3,0,0), 2, 2)
B  = matrix( c(4,2,0,1), 2, 2)
C  = c( 5, 0 )
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + AM(w[(k-1),])
}
w
w      <- rmvnorm( 100 , mean = mu , sigma = D )
w
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
N  = 100
x0 = c(3,2)
D  = diag(2) * c(0.5,0.2)
R  = diag(2) * c( 2, 1 )
A  = matrix( c(0,3,0,0), 2, 2)
B  = matrix( c(4,2,0,1), 2, 2)
C  = c( 5, 0 )
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
w      <- rmvnorm( 1 , mean = mu , sigma = D )
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + AM(w[(k-1),])
}
}
compute.states()
N  = 100
x0 = c(3,2)
D  = diag(2) * c(0.5,0.2)
R  = diag(2) * c( 2, 1 )
A  = matrix( c(0,3,0,0), 2, 2)
B  = matrix( c(4,2,0,1), 2, 2)
C  = c( 5, 0 )
# Set mean for disturbance
mu      <- c( 0 , 0 )
# Initialize storage objets and set corresponding starting conditions
x       <- matrix( NA , nrow = N , ncol = 2 )
x[1,]   <- x0
Q       <- C %*% t(C)
K       <- list()
K[[N]]  <- Q
L       <- list()
# Compute K and L matrices
for (k in (N-1):1){
K[[k]] <-   t(A) %*% ( K[[(k+1)]] - K[[(k+1)]] %*% B %*% solve( t(B) %*% K[[(k+1)]] %*% B + R ) %*% t(B) %*% K[[(k+1)]] ) %*% A + Q
L[[k]] <- - solve( t(B) %*% K[[(k+1)]] %*% B + R) %*% t(B) %*% K[[(k+1)]] %*% A
}
# Solve for the states
w      <- rmvnorm( 100 , mean = mu , sigma = D )
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + AM(w[(k-1),])
}
}
compute.states()
w      <- rmvnorm( 100 , mean = mu , sigma = D )
w
for( k in 2:N ){
u.temp <- L[[(k - 1)]] %*% x[(k-1),]
x[k,]  <- A %*% AM( x[(k-1),] ) + B %*% u.temp + AM(w[(k-1),])
}
x
matrix( c(0,3,0,0), 2, 2)
matrix( c(4,2,0,1), 2, 2)
install.packages("TMVA")
Set working directory
setwd("/Users/felix/Documents/GSE/Term 3/15D013 Topics in Big Data Analytics II/Problem sets/15D013-Topics-in-Big-Data-Analytics-II/PS1")
### Load Packages
if (!require("quantmod")) install.packages("quantmod"); library(quantmod)
if (!require("tseries"))  install.packages("tseries");  library(tseries)
if (!require("forecast")) install.packages("forecast"); library(forecast)
if (!require("fGarch"))   install.packages("fGarch");   library(fGarch)
if (!require("e1071"))    install.packages("e1071");    library(e1071)
if (!require("h2o"))      install.packages("h2o");      library(h2o)
### Initialize auxilliary functions
source("Auxilliary_Functions_PS1.R")
### Set working directory
setwd("/Users/felix/Documents/GSE/Term 3/15D013 Topics in Big Data Analytics II/Problem sets/15D013-Topics-in-Big-Data-Analytics-II/PS1")
### Load Packages
if (!require("quantmod")) install.packages("quantmod"); library(quantmod)
if (!require("tseries"))  install.packages("tseries");  library(tseries)
if (!require("forecast")) install.packages("forecast"); library(forecast)
if (!require("fGarch"))   install.packages("fGarch");   library(fGarch)
if (!require("e1071"))    install.packages("e1071");    library(e1071)
if (!require("h2o"))      install.packages("h2o");      library(h2o)
### Initialize auxilliary functions
source("Auxilliary_Functions_PS1.R")
# Get sentiment data and compute lenth
sentiment.index <- getSymbols( "UMCSENT" , src = "FRED" , auto.assign = FALSE )
N <- nrow(sentiment.index)
# Plot sentiment series
plot( sentiment.index )
# Compute ACF and PACF
sentiment.acf  <- acf( sentiment.index )
sentiment.pacf <- pacf( sentiment.index )
# for stationarity
adf.test( sentiment.index )
# Differencing the data to get stationary data
sentintement.diff <- diff( sentiment.index )
adf.test( sentintement.diff[2:N] )
# Fit auto arima model to find best fit
m01 <- auto.arima( sentintement.diff )
# Square data and check for volatility clustering
sentiment.squared <- sentiment.index**2
sentiment.acfP2   <- acf( sentiment.squared )
sentiment.PacfP2  <- pacf( sentiment.squared )
Box.test( sentiment.squared )
Box.test( sentiment.squared,type = "Ljung-Box" )
